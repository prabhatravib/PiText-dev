<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>PiText</title>
  <link rel="icon" href="/PiText_favicon.ico" type="image/x-icon" />

  <!-- 1) Import Mermaid once, disable auto-render -->
  <script type="module">
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: false });
    window.mermaid = mermaid;
  </script>

  <!-- 2) All your styles, including the background -->
  <style>
    body {
      background: url("/PiText_background.png") center center / 100% auto no-repeat;
      color: #f0f0f0;              /* set default text to a pale color */
      font-family: sans-serif;
      margin: 2rem;
      text-align: center;
    }

    h1 {
      margin-bottom: 2rem;
      color: #ffffff;              /* explicitly white for max contrast */
      text-shadow: 0 0 8px rgba(0,0,0,0.8);
    }

    input {
      padding: 0.5rem;
      font-size: 1rem;
      width: 300px;
      margin-right: 0.5rem;
    }

    button {
      padding: 0.5rem 1rem;
      font-size: 1rem;
    }

    #result {
      margin: 2rem auto;
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 4px;
      padding: 2rem;
      min-height: 50vh;
      max-width: 90vw;
      text-align: center;
      background-color: rgba(255, 255, 255, 0.1); /* Very subtle white overlay */
      backdrop-filter: blur(2px); /* Minimal blur to preserve background */
    }

    /* Selection indicator */
    .selection-indicator {
      margin: 1rem auto;
      padding: 1rem;
      background-color: rgba(0, 0, 0, 0.8);
      color: white;
      border-radius: 8px;
      max-width: 600px;
      display: none;
      font-size: 14px;
    }

    .selection-indicator.active {
      display: block;
    }

    .selection-display {
      margin-bottom: 1rem;
      padding-bottom: 0.5rem;
      border-bottom: 1px solid rgba(255, 255, 255, 0.3);
    }

    .deep-dive-input {
      display: flex;
      gap: 0.5rem;
      align-items: center;
    }

    .deep-dive-input input {
      flex: 1;
      padding: 0.5rem;
      font-size: 14px;
      background-color: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.3);
      color: white;
      border-radius: 4px;
    }

    .deep-dive-input input::placeholder {
      color: rgba(255, 255, 255, 0.6);
    }

    .deep-dive-input button {
      padding: 0.5rem 1rem;
      font-size: 14px;
      background-color: rgba(255, 255, 255, 0.2);
      color: white;
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.2s;
    }

    .deep-dive-input button:hover {
      background-color: rgba(255, 255, 255, 0.3);
    }

    /* Deep-dive response area */
    .deep-dive-response {
      margin: 1rem auto;
      padding: 1.5rem;
      background-color: rgba(0, 0, 0, 0.7);
      color: white;
      border-radius: 8px;
      max-width: 800px;
      display: none;
      font-size: 14px;
      line-height: 1.6;
      text-align: left;
    }

    .deep-dive-response.active {
      display: block;
    }

    .deep-dive-response h3 {
      margin-top: 0;
      margin-bottom: 0.5rem;
      color: #ffffff;
      font-size: 16px;
    }

    .deep-dive-response .question {
      font-style: italic;
      margin-bottom: 1rem;
      opacity: 0.8;
    }

    .deep-dive-response .answer {
      white-space: pre-wrap;
    }

    /* Highlight selected nodes */
    .node-selected text,
    .node-selected tspan,
    .node-selected .nodeLabel {
      font-weight: bold !important;
      font-size: 15px !important;
    }
    
    .node-selected rect,
    .node-selected circle,
    .node-selected ellipse,
    .node-selected polygon {
      stroke-width: 3px !important;
    }

    /* Make text elements selectable */
    .mermaid text {
      cursor: pointer;
      user-select: text;
    }

    .mermaid .nodeLabel {
      cursor: pointer;
    }

    /* Hover effect for selectable text */
    .mermaid g.node:hover text,
    .mermaid g.node:hover tspan,
    .mermaid g.node:hover .nodeLabel {
      font-weight: 600;
    }

    /* Enhanced arrow visibility styles with white outlines */
    .mermaid .edgePath path,
    .mermaid .flowchart-link,
    .mermaid path.path,
    .mermaid g.edgePath path,
    .mermaid g.edgePaths path {
      stroke: #000000 !important;
      stroke-width: 4px !important;
      fill: none !important;
      filter: drop-shadow(0 0 3px rgba(255, 255, 255, 0.9)) 
              drop-shadow(0 0 6px rgba(255, 255, 255, 0.8)) !important;
    }

    /* Enhanced arrowheads with outline */
    .mermaid .arrowheadPath,
    .mermaid .arrowhead path,
    .mermaid polygon.arrowheadPath,
    .mermaid marker path,
    .mermaid marker polygon,
    .mermaid defs marker path {
      fill: #000000 !important;
      stroke: #ffffff !important;
      stroke-width: 2px !important;
      filter: drop-shadow(0 0 2px rgba(255, 255, 255, 0.9)) !important;
    }

    /* Target connection lines specifically */
    .mermaid g.edgePath path,
    .mermaid g.edgePaths path {
      stroke: #000000 !important;
      stroke-width: 4px !important;
    }

    /* Edge labels with stronger background and shadow */
    .mermaid .edgeLabel {
      background-color: rgba(255, 255, 255, 0.95) !important;
      color: #000000 !important;
      border-radius: 3px !important;
      padding: 4px 8px !important;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4),
                  0 0 12px rgba(255, 255, 255, 0.8) !important;
      font-weight: bold !important;
    }

    /* Ensure flowchart connection lines are visible */
    .mermaid .flowchart-link {
      stroke: #000000 !important;
      stroke-width: 3px !important;
    }

    /* Style for any text on paths */
    .mermaid .edgeLabel text {
      fill: #000000 !important;
      font-weight: bold !important;
    }

    /* Ensure node text remains readable */
    .mermaid text {
      text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.8) !important;
    }

    .mermaid .nodeLabel {
      filter: drop-shadow(0 0 3px rgba(255, 255, 255, 0.9)) !important;
    }

    /* Additional contrast for the entire diagram */
    .mermaid svg {
      filter: drop-shadow(0 0 1px rgba(255, 255, 255, 0.5));
    }

    /* Force all polylines (alternative connection representation) to be black */
    .mermaid polyline {
      stroke: #000000 !important;
      stroke-width: 4px !important;
      fill: none !important;
      filter: drop-shadow(0 0 3px rgba(255, 255, 255, 0.9)) !important;
    }
  </style>
</head>

<body>
  <h1>Text Responses, using Pictures!</h1>
  <input id="query" placeholder="Ask anything!" />
  <button onclick="generateDiagram()">Generate</button>

  <div id="result">Your diagram will appear here.</div>
  
  <!-- Selection indicator and deep-dive input -->
  <div id="selectionIndicator" class="selection-indicator">
    <div class="selection-display">
      <strong>Selected:</strong> <span id="selectedText"></span>
    </div>
    <div class="deep-dive-input">
      <input id="deepDiveQuery" placeholder="Ask about this selection..." />
      <button onclick="askAboutSelection()">Ask</button>
    </div>
  </div>
  
  <!-- Deep-dive response area -->
  <div id="deepDiveResponse" class="deep-dive-response"></div>

  <script>
    let selectedElement = null;
    let selectedText = '';
    let currentQuery = '';  // Store the original query

    async function askAboutSelection() {
      const deepDiveQuery = document.getElementById('deepDiveQuery').value.trim();
      
      if (!deepDiveQuery || !selectedText) {
        return;
      }
      
      // Show loading state
      const responseDiv = document.getElementById('deepDiveResponse');
      responseDiv.innerHTML = '<div>Thinking...</div>';
      responseDiv.classList.add('active');
      
      try {
        const resp = await fetch('/deep-dive', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            selected_text: selectedText,
            question: deepDiveQuery,
            original_query: currentQuery
          })
        });
        
        const data = await resp.json();
        
        if (!data.success) {
          throw new Error(data.detail || 'Unknown error');
        }
        
        // Display the response
        responseDiv.innerHTML = `
          <h3>Deep Dive: ${selectedText}</h3>
          <div class="question">Q: ${deepDiveQuery}</div>
          <div class="answer">${data.response}</div>
        `;
        
        // Clear the input
        document.getElementById('deepDiveQuery').value = '';
        
      } catch (err) {
        responseDiv.innerHTML = `<div style="color: #ff6b6b;">Error: ${err.message}</div>`;
      }
    }

    function setupTextSelection(container) {
      const svg = container.querySelector('svg');
      if (!svg) return;

      // Find all nodes (they're in g elements with class 'node')
      const nodes = svg.querySelectorAll('g.node');
      
      nodes.forEach(node => {
        // Make the node clickable
        node.style.cursor = 'pointer';
        
        node.addEventListener('click', function(e) {
          // Remove previous selection
          if (selectedElement) {
            selectedElement.classList.remove('node-selected');
            // Remove bold from previous edge label if it was one
            if (selectedElement.classList && selectedElement.classList.contains('edgeLabel')) {
              const prevText = selectedElement.querySelector('text');
              if (prevText) prevText.style.fontWeight = 'normal';
            }
          }
          
          // Add selection to clicked node
          this.classList.add('node-selected');
          selectedElement = this;
          
          // Extract text from the node
          let nodeText = '';
          
          // Look for text elements in the node
          const textElement = this.querySelector('text');
          if (textElement) {
            // Get all tspan elements (these are individual lines)
            const tspans = textElement.querySelectorAll('tspan');
            if (tspans.length > 0) {
              // Join tspan contents with spaces
              const lines = Array.from(tspans).map(tspan => tspan.textContent.trim());
              nodeText = lines.filter(line => line).join(' ');
            } else {
              // Fallback to text content
              nodeText = textElement.textContent.trim();
            }
          }
          
          // If still no text, try other selectors
          if (!nodeText) {
            const nodeLabel = this.querySelector('.nodeLabel');
            if (nodeLabel) {
              nodeText = nodeLabel.textContent.trim();
            }
          }
          
          // Clean up any extra whitespace
          nodeText = nodeText.replace(/\s+/g, ' ').trim();
          
          // If no text found in standard elements, try the node's title or aria-label
          if (!nodeText) {
            const title = this.querySelector('title');
            if (title) nodeText = title.textContent.trim();
          }
          
          // Update selection indicator
          selectedText = nodeText;
          document.getElementById('selectedText').textContent = nodeText;
          document.getElementById('selectionIndicator').classList.add('active');
          
          // Focus the deep-dive input for convenience
          document.getElementById('deepDiveQuery').focus();
          
          console.log('Selected node text:', nodeText);
        });
      });

      // Also handle edge labels
      const edgeLabels = svg.querySelectorAll('.edgeLabel');
      edgeLabels.forEach(label => {
        label.style.cursor = 'pointer';
        
        label.addEventListener('click', function(e) {
          e.stopPropagation();
          
          // Remove previous selection
          if (selectedElement) {
            selectedElement.classList.remove('node-selected');
            // Remove bold from previous edge label if it was one
            if (selectedElement.classList.contains('edgeLabel')) {
              const prevText = selectedElement.querySelector('text');
              if (prevText) prevText.style.fontWeight = 'normal';
            }
          }
          
          // Bold this edge label's text
          const labelText = this.querySelector('text');
          if (labelText) labelText.style.fontWeight = 'bold';
          
          selectedElement = this;
          
          // Extract text
          const text = this.textContent.trim();
          selectedText = text;
          document.getElementById('selectedText').textContent = text;
          document.getElementById('selectionIndicator').classList.add('active');
          
          // Focus the deep-dive input
          document.getElementById('deepDiveQuery').focus();
          
          console.log('Selected edge label:', text);
        });
      });

      // Click on empty space to deselect
      svg.addEventListener('click', function(e) {
        if (e.target === svg || e.target.tagName === 'rect' && e.target.getAttribute('fill') === 'none') {
          if (selectedElement) {
            selectedElement.classList.remove('node-selected');
            // Remove bold from edge label if it was selected
            if (selectedElement.classList && selectedElement.classList.contains('edgeLabel')) {
              const labelText = selectedElement.querySelector('text');
              if (labelText) labelText.style.fontWeight = 'normal';
            }
            selectedElement = null;
            selectedText = '';
            document.getElementById('selectionIndicator').classList.remove('active');
            document.getElementById('deepDiveQuery').value = '';  // Clear the input
            document.getElementById('deepDiveResponse').classList.remove('active');  // Hide response
          }
        }
      });
    }

    function forceArrowVisibility(container) {
      // Wait a moment for SVG to be fully rendered
      setTimeout(() => {
        const svg = container.querySelector('svg');
        if (!svg) return;
        
        // Force all path elements (arrows/connections) to be black and thick
        const paths = svg.querySelectorAll('path');
        paths.forEach(path => {
          // Check if this path is likely a connection line (not a node shape)
          const pathData = path.getAttribute('d');
          if (pathData && (pathData.includes('M') && pathData.includes('L'))) {
            path.setAttribute('stroke', '#000000');
            path.setAttribute('stroke-width', '4');
            path.setAttribute('fill', 'none');
            // Add white outline effect
            path.style.filter = 'drop-shadow(0 0 3px rgba(255, 255, 255, 0.9))';
          }
        });
        
        // Force all markers (arrowheads) to be black with white outline
        const markers = svg.querySelectorAll('marker path, marker polygon');
        markers.forEach(marker => {
          marker.setAttribute('fill', '#000000');
          marker.setAttribute('stroke', '#ffffff');
          marker.setAttribute('stroke-width', '2');
        });
        
        // Force all polylines (alternative connection representation) to be black
        const polylines = svg.querySelectorAll('polyline');
        polylines.forEach(polyline => {
          polyline.setAttribute('stroke', '#000000');
          polyline.setAttribute('stroke-width', '4');
          polyline.setAttribute('fill', 'none');
          polyline.style.filter = 'drop-shadow(0 0 3px rgba(255, 255, 255, 0.9))';
        });
        
        // Force edge paths specifically
        const edgePaths = svg.querySelectorAll('g.edgePath path, g.edgePaths path, .edgePath path');
        edgePaths.forEach(edge => {
          edge.setAttribute('stroke', '#000000');
          edge.setAttribute('stroke-width', '4');
          edge.setAttribute('fill', 'none');
          edge.style.filter = 'drop-shadow(0 0 3px rgba(255, 255, 255, 0.9))';
        });
        
        console.log('Forced arrow visibility on', paths.length, 'paths and', markers.length, 'markers');
      }, 50);
    }

    async function generateDiagram() {
      const query = document.getElementById('query').value.trim();
      const resultDiv = document.getElementById('result');
      if (!query) {
        resultDiv.textContent = 'Please enter a query.';
        return;
      }
      
      // Store the current query for deep-dive context
      currentQuery = query;
      
      // Clear any previous selection and responses
      selectedElement = null;
      selectedText = '';
      document.getElementById('selectionIndicator').classList.remove('active');
      document.getElementById('deepDiveQuery').value = '';
      document.getElementById('deepDiveResponse').classList.remove('active');
      
      resultDiv.textContent = 'Generatingâ€¦';
      try {
        const resp = await fetch('/describe', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ query })
        });
        const data = await resp.json();
        if (!data.success) {
          throw new Error(data.detail || 'Unknown error');
        }
        // Inject only the Mermaid snippet
        resultDiv.innerHTML = `<div class="mermaid">${data.diagram}</div>`;

        // Render it and handle any syntax errors
        try {
          await window.mermaid.init(undefined, resultDiv.querySelector('.mermaid'));
          
          // Force all arrows to be visible after rendering
          forceArrowVisibility(resultDiv);
          
          // Setup text selection
          setupTextSelection(resultDiv);
          
          setTimeout(() => {
            const errorElement = resultDiv.querySelector('.mermaidError, [data-mermaid-error], .error');
            const hasErrorText = resultDiv.textContent.includes('Syntax error') ||
                                 resultDiv.textContent.includes('Error');
            if (errorElement || hasErrorText) {
              resultDiv.innerHTML = '<div style="color: #666; font-size: 24px; padding: 40px;">Some issue. Please generate again</div>';
            }
          }, 100);
        } catch {
          resultDiv.innerHTML = '<div style="color: #666; font-size: 24px; padding: 40px;">Some issue. Please generate again</div>';
        }
      } catch (err) {
        resultDiv.textContent = `Error: ${err.message}`;
      }
    }

    // Add Enter key support for deep-dive input
    document.getElementById('deepDiveQuery').addEventListener('keypress', function(e) {
      if (e.key === 'Enter') {
        askAboutSelection();
      }
    });
  </script>
</body>
</html>
