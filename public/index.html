<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>PiText</title>
  <link rel="icon" href="/PiText_favicon.ico" type="image/x-icon"/>

  <!-- 1) Load the UMD build of Mermaid so `mermaid` is a global -->
  <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>

  <!-- 2) All your CSS, including hover-highlight option 1 -->
  <style>
    body {
      background-color: #000;
      background-image: url("/PiText_background.png");
      background-position: center center;
      background-size: 100% auto;
      background-repeat: no-repeat;
      background-attachment: fixed;
      color: #f0f0f0;
      font-family: sans-serif;
      margin: 2rem;
      text-align: center;
      min-height: 100vh;
    }
    h1 {
      margin-bottom: 2rem;
      color: #fff;
      text-shadow: 0 0 8px rgba(0,0,0,0.8);
    }
    input {
      padding: .5rem;
      font-size: 1rem;
      width: 300px;
      margin-right: .5rem;
    }
    button {
      padding: .5rem 1rem;
      font-size: 1rem;
      cursor: pointer;
    }
    #result {
      margin: 2rem auto;
      border: 1px solid rgba(255,255,255,0.3);
      border-radius: 4px;
      padding: 2rem;
      min-height: 50vh;
      max-width: 90vw;
      background-color: rgba(255,255,255,0.1);
      backdrop-filter: blur(2px);
      text-align: center;
    }

    /* Selection indicator */
    .selection-indicator {
      margin: 1rem auto;
      padding: 1rem;
      background-color: rgba(0,0,0,0.8);
      color: #fff;
      border-radius: 8px;
      max-width: 600px;
      display: none;
      font-size: 14px;
    }
    .selection-indicator.active {
      display: block;
    }
    .selection-display {
      margin-bottom: 1rem;
      padding-bottom: .5rem;
      border-bottom: 1px solid rgba(255,255,255,0.3);
    }
    .deep-dive-input {
      display: flex;
      gap: .5rem;
      align-items: center;
    }
    .deep-dive-input input {
      flex: 1;
      padding: .5rem;
      font-size: 14px;
      background-color: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.3);
      color: #fff;
      border-radius: 4px;
    }
    .deep-dive-input input::placeholder {
      color: rgba(255,255,255,0.6);
    }
    .deep-dive-input button {
      padding: .5rem 1rem;
      font-size: 14px;
      background-color: rgba(255,255,255,0.2);
      color: #fff;
      border: 1px solid rgba(255,255,255,0.3);
      border-radius: 4px;
      transition: background-color .2s;
    }
    .deep-dive-input button:hover {
      background-color: rgba(255,255,255,0.3);
    }

    /* Deep-dive response area */
    .deep-dive-response {
      margin: 1rem auto;
      padding: 1.5rem;
      background-color: rgba(0,0,0,0.7);
      color: #fff;
      border-radius: 8px;
      max-width: 800px;
      display: none;
      font-size: 14px;
      line-height: 1.6;
      text-align: left;
    }
    .deep-dive-response.active {
      display: block;
    }
    .deep-dive-response h3 {
      margin-top: 0;
      margin-bottom: .5rem;
      color: #fff;
      font-size: 16px;
    }
    .deep-dive-response .question {
      font-style: italic;
      margin-bottom: 1rem;
      opacity: .8;
    }
    .deep-dive-response .answer {
      white-space: pre-wrap;
    }

    /* Highlight selected nodes */
    .node-selected text,
    .node-selected tspan,
    .node-selected .nodeLabel {
      font-weight: bold !important;
      font-size: 15px !important;
    }
    .node-selected rect,
    .node-selected circle,
    .node-selected ellipse,
    .node-selected polygon {
      stroke-width: 3px !important;
    }

    /* Make text selectable */
    .mermaid text {
      cursor: text;
      user-select: text;
      text-shadow: 1px 1px 2px rgba(255,255,255,0.8) !important;
    }
    .mermaid .nodeLabel {
      filter: drop-shadow(0 0 3px rgba(255,255,255,0.9)) !important;
    }

    /* Enhanced arrows */
    .mermaid .edgePath path,
    .mermaid .flowchart-link,
    .mermaid path.path,
    .mermaid g.edgePath path,
    .mermaid g.edgePaths path {
      stroke: #000 !important;
      stroke-width: 4px !important;
      fill: none !important;
      filter:
        drop-shadow(0 0 3px rgba(255,255,255,0.9))
        drop-shadow(0 0 6px rgba(255,255,255,0.8)) !important;
    }
    .mermaid .arrowheadPath,
    .mermaid .arrowhead path,
    .mermaid polygon.arrowheadPath,
    .mermaid marker path,
    .mermaid marker polygon,
    .mermaid defs marker path {
      fill: #000 !important;
      stroke: #fff !important;
      stroke-width: 2px !important;
      filter: drop-shadow(0 0 2px rgba(255,255,255,0.9)) !important;
    }
    .mermaid .edgeLabel {
      background-color: rgba(255,255,255,0.95) !important;
      color: #000 !important;
      border-radius: 3px !important;
      padding: 4px 8px !important;
      box-shadow:
        0 2px 8px rgba(0,0,0,0.4),
        0 0 12px rgba(255,255,255,0.8) !important;
      font-weight: bold !important;
    }
    .mermaid .edgeLabel text {
      fill: #000 !important;
      font-weight: bold !important;
    }
    .mermaid .flowchart-link,
    .mermaid polyline {
      stroke: #000 !important;
      stroke-width: 4px !important;
      fill: none !important;
      filter: drop-shadow(0 0 3px rgba(255,255,255,0.9)) !important;
    }

    /* ---------- Option 1: hover-highlight without moving --------- */
    .mermaid g.node:hover rect {
      stroke-width: 3px !important;
    }
    .mermaid g.node:hover text,
    .mermaid g.node:hover tspan {
      font-weight: 600 !important;
    }
  </style>
</head>
<body>
  <h1>Text Responses, using Pictures!</h1>
  <input id="query" placeholder="Ask anything!"/>
  <button id="generateBtn">Generate</button>

  <div id="result">Your diagram will appear here.</div>
  
  <!-- Selection indicator and deep-dive input -->
  <div id="selectionIndicator" class="selection-indicator">
    <div class="selection-display">
      <strong>Selected:</strong> <span id="selectedText"></span>
    </div>
    <div class="deep-dive-input">
      <input id="deepDiveQuery" placeholder="Ask about this selection..."/>
      <button id="askBtn">Ask</button>
    </div>
  </div>
  
  <!-- Deep-dive response area -->
  <div id="deepDiveResponse" class="deep-dive-response"></div>

  <script>
    // Initialize Mermaid
    mermaid.initialize({ startOnLoad: false });

    // UI state
    let selectedElement = null;
    let selectedText = '';
    let currentQuery = '';

    // Button wiring
    document.getElementById('generateBtn')
            .addEventListener('click', generateDiagram);
    document.getElementById('askBtn')
            .addEventListener('click', askAboutSelection);
    document.getElementById('deepDiveQuery')
            .addEventListener('keypress', e => { if (e.key === 'Enter') askAboutSelection(); });

    // Deep-dive on selected node/edge
    async function askAboutSelection() {
      const q = document.getElementById('deepDiveQuery').value.trim();
      if (!q || !selectedText) return;

      const respDiv = document.getElementById('deepDiveResponse');
      respDiv.innerHTML = '<div>Thinking...</div>';
      respDiv.classList.add('active');

      try {
        const resp = await fetch('/deep-dive', {
          method: 'POST',
          headers: {'Content-Type':'application/json'},
          body: JSON.stringify({
            selected_text: selectedText,
            question: q,
            original_query: currentQuery
          })
        });
        const data = await resp.json();
        if (!data.success) throw new Error(data.detail||'Unknown error');

        respDiv.innerHTML = `
          <h3>Deep Dive: ${selectedText}</h3>
          <div class="question">Q: ${q}</div>
          <div class="answer">${data.response}</div>
        `;
        document.getElementById('deepDiveQuery').value = '';
      } catch (err) {
        respDiv.innerHTML = `<div style="color:#ff6b6b;">Error: ${err.message}</div>`;
      }
    }

    // Make nodes & edges selectable
    function setupTextSelection(container) {
      const svg = container.querySelector('svg');
      if (!svg) return;
      // Nodes
      svg.querySelectorAll('g.node').forEach(node => {
        node.style.cursor = 'pointer';
        node.addEventListener('click', function(e) {
          if (selectedElement) {
            selectedElement.classList.remove('node-selected');
            if (selectedElement.classList.contains('edgeLabel')) {
              const t = selectedElement.querySelector('text');
              if (t) t.style.fontWeight = 'normal';
            }
          }
          this.classList.add('node-selected');
          selectedElement = this;

          // Extract text
          let txt = '';
          const textEl = this.querySelector('text');
          if (textEl) {
            const tspans = textEl.querySelectorAll('tspan');
            txt = tspans.length
                  ? Array.from(tspans).map(t=>t.textContent.trim()).filter(Boolean).join(' ')
                  : textEl.textContent.trim();
          }
          if (!txt) {
            const lbl = this.querySelector('.nodeLabel');
            if (lbl) txt = lbl.textContent.trim();
          }
          if (!txt) {
            const title = this.querySelector('title');
            if (title) txt = title.textContent.trim();
          }
          selectedText = txt.replace(/\s+/g,' ').trim();

          document.getElementById('selectedText').textContent = selectedText;
          document.getElementById('selectionIndicator').classList.add('active');
          document.getElementById('deepDiveQuery').focus();
        });
      });
      // Edge labels
      svg.querySelectorAll('.edgeLabel').forEach(label => {
        label.style.cursor = 'pointer';
        label.addEventListener('click', function(e) {
          e.stopPropagation();
          if (selectedElement) {
            selectedElement.classList.remove('node-selected');
            if (selectedElement.classList.contains('edgeLabel')) {
              const t = selectedElement.querySelector('text');
              if (t) t.style.fontWeight = 'normal';
            }
          }
          const tEl = this.querySelector('text');
          if (tEl) tEl.style.fontWeight = 'bold';
          selectedElement = this;
          selectedText = this.textContent.trim();

          document.getElementById('selectedText').textContent = selectedText;
          document.getElementById('selectionIndicator').classList.add('active');
          document.getElementById('deepDiveQuery').focus();
        });
      });
      // Deselect on blank click
      svg.addEventListener('click', function(e) {
        if (e.target === svg || (e.target.tagName==='rect' && e.target.getAttribute('fill')==='none')) {
          if (selectedElement) {
            selectedElement.classList.remove('node-selected');
            if (selectedElement.classList.contains('edgeLabel')) {
              const t = selectedElement.querySelector('text');
              if (t) t.style.fontWeight='normal';
            }
            selectedElement = null;
            selectedText = '';
            document.getElementById('selectionIndicator').classList.remove('active');
            document.getElementById('deepDiveQuery').value = '';
            document.getElementById('deepDiveResponse').classList.remove('active');
          }
        }
      });
    }

    // Force arrow styling after render
    function forceArrowVisibility(container) {
      setTimeout(() => {
        const svg = container.querySelector('svg');
        if (!svg) return;
        svg.querySelectorAll('path').forEach(path => {
          const d = path.getAttribute('d')||'';
          if (d.includes('M') && d.includes('L')) {
            path.setAttribute('stroke','#000');
            path.setAttribute('stroke-width','4');
            path.setAttribute('fill','none');
            path.style.filter = 'drop-shadow(0 0 3px rgba(255,255,255,0.9))';
          }
        });
        svg.querySelectorAll('marker path, marker polygon').forEach(m => {
          m.setAttribute('fill','#000');
          m.setAttribute('stroke','#fff');
          m.setAttribute('stroke-width','2');
        });
        svg.querySelectorAll('polyline').forEach(pl => {
          pl.setAttribute('stroke','#000');
          pl.setAttribute('stroke-width','4');
          pl.setAttribute('fill','none');
          pl.style.filter = 'drop-shadow(0 0 3px rgba(255,255,255,0.9))';
        });
        svg.querySelectorAll('g.edgePath path, g.edgePaths path, .edgePath path')
           .forEach(ep => {
             ep.setAttribute('stroke','#000');
             ep.setAttribute('stroke-width','4');
             ep.setAttribute('fill','none');
             ep.style.filter = 'drop-shadow(0 0 3px rgba(255,255,255,0.9))';
           });
      }, 50);
    }

    // Generate & render the diagram
    async function generateDiagram() {
      const q = document.getElementById('query').value.trim();
      const resultDiv = document.getElementById('result');
      if (!q) {
        resultDiv.textContent = 'Please enter a query.';
        return;
      }
      currentQuery = q;
      // Clear prior state
      selectedElement = null;
      selectedText = '';
      document.getElementById('selectionIndicator').classList.remove('active');
      document.getElementById('deepDiveQuery').value = '';
      document.getElementById('deepDiveResponse').classList.remove('active');

      resultDiv.textContent = 'Generating…';
      try {
        const resp = await fetch('/describe', {
          method: 'POST',
          headers: {'Content-Type':'application/json'},
          body: JSON.stringify({ query: q })
        });
        const data = await resp.json();
        if (!data.success) throw new Error(data.detail||'Unknown error');

        resultDiv.innerHTML = `<div class="mermaid">${data.diagram}</div>`;
        try {
          mermaid.init(undefined, resultDiv.querySelector('.mermaid'));
          forceArrowVisibility(resultDiv);
          setupTextSelection(resultDiv);
          // Catch any render errors
          setTimeout(() => {
            const errEl = resultDiv.querySelector('.mermaidError, [data-mermaid-error], .error');
            if (errEl || /Syntax error|Error/.test(resultDiv.textContent)) {
              resultDiv.innerHTML = '<div style="color:#666;font-size:24px;padding:40px;">Some issue. Please generate again</div>';
            }
          }, 100);
        } catch {
          resultDiv.innerHTML = '<div style="color:#666;font-size:24px;padding:40px;">Some issue. Please generate again</div>';
        }
      } catch (err) {
        resultDiv.textContent = `Error: ${err.message}`;
      }
    }
  </script>
</body>
</html>
